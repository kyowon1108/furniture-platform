# 자유 건축 및 AI Depth Map 기능 - 상세 구현 계획서

## 1. 현재 코드베이스 분석 요약

### 1.1 기존 구조의 강점 (재사용 가능)

| 컴포넌트 | 파일 | 재사용 가능 요소 |
|---------|------|-----------------|
| 타일 렌더링 | `RoomScene.tsx` | TileMesh 컴포넌트, 텍스처 로딩 로직 |
| 타일 선택 | `RoomBuilderComplete.tsx` | Shift/Ctrl 클릭 다중 선택 로직 |
| GLB 내보내기 | `RoomBuilderComplete.tsx` | GLTFExporter, UV 재계산 로직 |
| 상태 관리 | `editorStore.ts`, `materialStore.ts` | Zustand 패턴, undo/redo |
| 백엔드 API | `room_builder.py` | Bedrock 연동, 이미지 처리 |
| DB 모델 | `project.py`, `layout.py` | JSON 필드, 관계 설정 |

### 1.2 새로 구현해야 할 기능

| 기능 | 설명 | 난이도 |
|------|------|--------|
| 자유 타일 배치 | 빈 그리드에서 클릭으로 바닥/벽 타일 생성 | 중 |
| 타일 삭제 | 지우개 도구로 타일 제거 | 하 |
| 자동 벽 생성 | 바닥 타일 경계에 벽 자동 생성 옵션 | 중 |
| 건축 모드 UI | 도구 선택 툴바 (배치/선택/삭제) | 중 |
| Depth Map API | Depth Anything V2 연동 백엔드 API | 상 |
| Displacement 적용 | Three.js displacement map 재질 적용 | 중 |
| Geometry Baking | GLB 내보내기 전 geometry 변환 | 상 |
| 건축 상태 저장 | 자유 타일 배치 데이터 DB 저장 | 중 |

---

## 2. 수정이 필요한 파일 목록

### 2.1 Frontend (신규 생성)

```
frontend/
├── components/
│   ├── room-builder/
│   │   ├── FreeBuildMode.tsx         # 자유 건축 메인 컴포넌트 (신규)
│   │   ├── BuildToolbar.tsx          # 건축 도구 툴바 (신규)
│   │   ├── FreeBuildScene.tsx        # 자유 건축 3D 씬 (신규)
│   │   └── DepthMapApplier.tsx       # Depth Map 적용 UI (신규)
│   └── 3d/
│       └── DisplacementTileMesh.tsx  # Displacement 지원 타일 (신규)
├── store/
│   └── freeBuildStore.ts             # 자유 건축 상태 관리 (신규)
└── types/
    └── freeBuild.ts                  # 타입 정의 (신규)
```

### 2.2 Frontend (수정 필요)

| 파일 | 수정 내용 |
|------|----------|
| `types.ts` | FreeBuildTile 타입, BuildMode enum 추가 |
| `RoomScene.tsx` | FreeBuildMode와 통합, 선택적 자유 배치 지원 |
| `RoomBuilderComplete.tsx` | Geometry Baking 로직 추가 |
| `materialStore.ts` | displacementMap, displacementScale 상태 추가 |

### 2.3 Backend (신규 생성)

```
backend/
├── app/
│   ├── api/v1/
│   │   └── depth_estimation.py       # Depth Map 생성 API (신규)
│   └── utils/
│       └── depth_utils.py            # Depth Anything V2 유틸리티 (신규)
```

### 2.4 Backend (수정 필요)

| 파일 | 수정 내용 |
|------|----------|
| `project.py` | room_structure JSON 필드 추가 |
| `layout.py` | tile_state JSON 필드 추가 |
| `main.py` | depth_estimation 라우터 등록 |
| `requirements.txt` | transformers, torch 추가 |

### 2.5 Database Migration

```sql
-- alembic migration
ALTER TABLE projects ADD COLUMN room_structure TEXT;  -- JSON for free-build tiles
ALTER TABLE layouts ADD COLUMN tile_state TEXT;       -- JSON for tile textures/depth
```

---

## 3. 상세 구현 계획

### Phase 1: 자유 건축 모드 (Frontend)

#### 3.1.1 타입 정의 (`types/freeBuild.ts`)

```typescript
export type BuildTool = 'select' | 'floor' | 'wall' | 'eraser';

export interface FreeBuildTile {
  id: string;
  type: 'floor' | 'wall';
  gridX: number;
  gridZ: number;
  gridY?: number;  // 벽의 경우 높이 인덱스
  wallDirection?: 'north' | 'south' | 'east' | 'west';
  textureUrl?: string;
  depthMapUrl?: string;
  displacementScale?: number;
}

export interface FreeBuildState {
  isFreeBuildMode: boolean;
  currentTool: BuildTool;
  tiles: FreeBuildTile[];
  selectedTileIds: string[];
  gridSize: number;  // 그리드 전체 크기 (예: 20x20)
  tileSize: number;  // 타일 크기 (0.5m)
  wallHeight: number; // 벽 높이 (2.5m)
}
```

#### 3.1.2 Zustand 스토어 (`store/freeBuildStore.ts`)

```typescript
interface FreeBuildStore extends FreeBuildState {
  // 도구 선택
  setCurrentTool: (tool: BuildTool) => void;

  // 타일 관리
  addTile: (tile: FreeBuildTile) => void;
  removeTile: (id: string) => void;
  updateTile: (id: string, updates: Partial<FreeBuildTile>) => void;

  // 선택
  selectTile: (id: string, multiSelect: boolean) => void;
  clearSelection: () => void;

  // 벽 자동 생성
  generateWallsFromFloor: () => void;

  // Depth Map 적용
  applyDepthMap: (tileIds: string[], depthMapUrl: string, scale: number) => void;

  // 저장/불러오기
  exportTileData: () => FreeBuildTile[];
  importTileData: (tiles: FreeBuildTile[]) => void;

  // Undo/Redo
  history: FreeBuildTile[][];
  historyIndex: number;
  undo: () => void;
  redo: () => void;
}
```

#### 3.1.3 FreeBuildScene 컴포넌트

```typescript
// 핵심 로직
const handleGridClick = (gridX: number, gridZ: number) => {
  const { currentTool, tiles, addTile, removeTile } = useFreeBuildStore();

  switch (currentTool) {
    case 'floor':
      // 해당 위치에 바닥 타일 추가
      const existingFloor = tiles.find(t =>
        t.type === 'floor' && t.gridX === gridX && t.gridZ === gridZ
      );
      if (!existingFloor) {
        addTile({
          id: `floor-${gridX}-${gridZ}`,
          type: 'floor',
          gridX, gridZ
        });
      }
      break;

    case 'wall':
      // 클릭 위치에 따라 벽 방향 결정
      const wallDirection = determineWallDirection(clickPosition, gridCenter);
      addTile({
        id: `wall-${gridX}-${gridZ}-${wallDirection}`,
        type: 'wall',
        gridX, gridZ,
        wallDirection
      });
      break;

    case 'eraser':
      // 해당 위치 타일 삭제
      const tileToRemove = tiles.find(t =>
        t.gridX === gridX && t.gridZ === gridZ
      );
      if (tileToRemove) removeTile(tileToRemove.id);
      break;
  }
};
```

#### 3.1.4 자동 벽 생성 알고리즘

```typescript
const generateWallsFromFloor = () => {
  const { tiles, addTile } = get();
  const floorTiles = tiles.filter(t => t.type === 'floor');
  const floorSet = new Set(floorTiles.map(t => `${t.gridX},${t.gridZ}`));

  const newWalls: FreeBuildTile[] = [];
  const wallHeight = get().wallHeight;
  const tilesPerWallHeight = Math.floor(wallHeight / get().tileSize);

  floorTiles.forEach(floor => {
    const { gridX, gridZ } = floor;
    const neighbors = [
      { dx: 0, dz: -1, dir: 'north' },
      { dx: 0, dz: 1, dir: 'south' },
      { dx: -1, dz: 0, dir: 'west' },
      { dx: 1, dz: 0, dir: 'east' },
    ];

    neighbors.forEach(({ dx, dz, dir }) => {
      const neighborKey = `${gridX + dx},${gridZ + dz}`;
      // 이웃에 바닥 타일이 없으면 벽 생성
      if (!floorSet.has(neighborKey)) {
        for (let y = 0; y < tilesPerWallHeight; y++) {
          newWalls.push({
            id: `wall-${gridX}-${gridZ}-${dir}-${y}`,
            type: 'wall',
            gridX, gridZ,
            gridY: y,
            wallDirection: dir as any
          });
        }
      }
    });
  });

  // 기존 벽 제거 후 새 벽 추가
  set(state => ({
    tiles: [
      ...state.tiles.filter(t => t.type !== 'wall'),
      ...newWalls
    ]
  }));
};
```

---

### Phase 2: AI Depth Map 통합

#### 3.2.1 Backend API (`depth_estimation.py`)

```python
from fastapi import APIRouter, File, UploadFile, HTTPException
from transformers import pipeline
from PIL import Image
import io
import base64
import torch

router = APIRouter()

# 모델 초기화 (lazy loading)
_depth_estimator = None

def get_depth_estimator():
    global _depth_estimator
    if _depth_estimator is None:
        device = "cuda" if torch.cuda.is_available() else "cpu"
        _depth_estimator = pipeline(
            "depth-estimation",
            model="depth-anything/Depth-Anything-V2-Small-hf",
            device=device
        )
    return _depth_estimator

@router.post("/generate-depth")
async def generate_depth_map(file: UploadFile = File(...)):
    """
    이미지에서 Depth Map 생성
    """
    try:
        # 이미지 로드
        contents = await file.read()
        image = Image.open(io.BytesIO(contents)).convert("RGB")

        # Depth 추정
        depth_estimator = get_depth_estimator()
        result = depth_estimator(image)

        # Depth 이미지 추출
        depth_image = result["depth"]

        # Base64로 변환
        buffer = io.BytesIO()
        depth_image.save(buffer, format="PNG")
        depth_base64 = base64.b64encode(buffer.getvalue()).decode()

        return {
            "depth_map_url": f"data:image/png;base64,{depth_base64}",
            "width": depth_image.width,
            "height": depth_image.height
        }

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/generate-depth-from-url")
async def generate_depth_from_url(request: DepthFromUrlRequest):
    """
    URL에서 이미지를 가져와 Depth Map 생성
    """
    import requests

    try:
        # URL에서 이미지 다운로드
        response = requests.get(request.image_url, timeout=30)
        image = Image.open(io.BytesIO(response.content)).convert("RGB")

        # Depth 추정
        depth_estimator = get_depth_estimator()
        result = depth_estimator(image)
        depth_image = result["depth"]

        # 저장 (S3 또는 로컬)
        # ... 저장 로직

        return {
            "depth_map_url": saved_url,
            "original_url": request.image_url
        }

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
```

#### 3.2.2 Frontend Depth Map 적용 UI

```typescript
// DepthMapApplier.tsx
const DepthMapApplier: React.FC = () => {
  const { selectedTileIds, tiles, applyDepthMap } = useFreeBuildStore();
  const [isGenerating, setIsGenerating] = useState(false);
  const [displacementScale, setDisplacementScale] = useState(0.1);

  const handleGenerateDepth = async () => {
    if (selectedTileIds.length === 0) return;

    setIsGenerating(true);

    try {
      // 선택된 타일의 텍스처 URL 수집
      const selectedTiles = tiles.filter(t => selectedTileIds.includes(t.id));
      const textureUrls = [...new Set(selectedTiles.map(t => t.textureUrl).filter(Boolean))];

      // 각 텍스처에 대해 Depth Map 생성
      for (const textureUrl of textureUrls) {
        const response = await fetch('/api/v1/depth/generate-depth-from-url', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ image_url: textureUrl })
        });

        const data = await response.json();

        // 해당 텍스처를 가진 선택된 타일들에 Depth Map 적용
        const affectedTileIds = selectedTiles
          .filter(t => t.textureUrl === textureUrl)
          .map(t => t.id);

        applyDepthMap(affectedTileIds, data.depth_map_url, displacementScale);
      }
    } finally {
      setIsGenerating(false);
    }
  };

  return (
    <div className="depth-map-applier">
      <h3>AI Depth Map</h3>

      <div className="slider-container">
        <label>Displacement 강도: {displacementScale.toFixed(2)}</label>
        <input
          type="range"
          min="0"
          max="0.5"
          step="0.01"
          value={displacementScale}
          onChange={(e) => setDisplacementScale(parseFloat(e.target.value))}
        />
      </div>

      <button
        onClick={handleGenerateDepth}
        disabled={isGenerating || selectedTileIds.length === 0}
      >
        {isGenerating ? 'Depth Map 생성 중...' : '선택 타일에 Depth Map 적용'}
      </button>
    </div>
  );
};
```

#### 3.2.3 DisplacementTileMesh 컴포넌트

```typescript
// DisplacementTileMesh.tsx
const DisplacementTileMesh: React.FC<{
  tile: FreeBuildTile;
  isSelected: boolean;
}> = ({ tile, isSelected }) => {
  const [colorTexture, setColorTexture] = useState<THREE.Texture | null>(null);
  const [depthTexture, setDepthTexture] = useState<THREE.Texture | null>(null);

  // 텍스처 로딩
  useEffect(() => {
    if (tile.textureUrl) {
      new THREE.TextureLoader().load(tile.textureUrl, (tex) => {
        tex.colorSpace = THREE.SRGBColorSpace;
        setColorTexture(tex);
      });
    }

    if (tile.depthMapUrl) {
      new THREE.TextureLoader().load(tile.depthMapUrl, (tex) => {
        setDepthTexture(tex);
      });
    }
  }, [tile.textureUrl, tile.depthMapUrl]);

  // 위치 계산
  const position = useMemo(() => {
    const x = tile.gridX * TILE_SIZE + TILE_SIZE / 2;
    const z = tile.gridZ * TILE_SIZE + TILE_SIZE / 2;
    const y = tile.type === 'wall' ? (tile.gridY || 0) * TILE_SIZE + TILE_SIZE / 2 : 0;
    return [x, y, z] as [number, number, number];
  }, [tile]);

  // Displacement 지원을 위해 정점 수 증가
  const geometry = useMemo(() => {
    return new THREE.PlaneGeometry(TILE_SIZE, TILE_SIZE, 32, 32);
  }, []);

  return (
    <mesh
      position={position}
      rotation={tile.type === 'floor' ? [-Math.PI / 2, 0, 0] : getWallRotation(tile.wallDirection)}
      geometry={geometry}
    >
      <meshStandardMaterial
        map={colorTexture}
        displacementMap={depthTexture}
        displacementScale={tile.displacementScale || 0}
        side={THREE.DoubleSide}
        color={isSelected ? '#4CAF50' : '#ffffff'}
      />
    </mesh>
  );
};
```

#### 3.2.4 Geometry Baking (GLB 내보내기용)

```typescript
// geometryBaker.ts
export function bakeDisplacementToGeometry(
  geometry: THREE.BufferGeometry,
  displacementMap: THREE.Texture,
  scale: number
): THREE.BufferGeometry {
  const bakedGeometry = geometry.clone();
  const positions = bakedGeometry.attributes.position;
  const uvs = bakedGeometry.attributes.uv;
  const normals = bakedGeometry.attributes.normal;

  // Displacement map을 캔버스로 읽기
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d')!;
  const img = displacementMap.image as HTMLImageElement;

  canvas.width = img.width;
  canvas.height = img.height;
  ctx.drawImage(img, 0, 0);

  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

  for (let i = 0; i < positions.count; i++) {
    const u = uvs.getX(i);
    const v = uvs.getY(i);

    // UV로 픽셀 위치 계산
    const x = Math.floor(u * canvas.width);
    const y = Math.floor((1 - v) * canvas.height);
    const idx = (y * canvas.width + x) * 4;

    // 그레이스케일 값 (0-1)
    const displacement = imageData.data[idx] / 255;

    // 노멀 방향으로 정점 이동
    const nx = normals.getX(i);
    const ny = normals.getY(i);
    const nz = normals.getZ(i);

    positions.setX(i, positions.getX(i) + nx * displacement * scale);
    positions.setY(i, positions.getY(i) + ny * displacement * scale);
    positions.setZ(i, positions.getZ(i) + nz * displacement * scale);
  }

  positions.needsUpdate = true;
  bakedGeometry.computeVertexNormals();

  return bakedGeometry;
}

// GLB 내보내기 시 사용
async function exportWithBakedDisplacement(scene: THREE.Group) {
  const clonedScene = scene.clone(true);

  clonedScene.traverse((obj) => {
    if (obj instanceof THREE.Mesh) {
      const material = obj.material as THREE.MeshStandardMaterial;

      if (material.displacementMap && material.displacementScale > 0) {
        // Geometry baking
        obj.geometry = bakeDisplacementToGeometry(
          obj.geometry,
          material.displacementMap,
          material.displacementScale
        );

        // Displacement map 제거 (baking 완료)
        material.displacementMap = null;
        material.displacementScale = 0;
      }
    }
  });

  const exporter = new GLTFExporter();
  return new Promise<Blob>((resolve, reject) => {
    exporter.parse(
      clonedScene,
      (gltf) => {
        const blob = new Blob([gltf as ArrayBuffer], { type: 'model/gltf-binary' });
        resolve(blob);
      },
      reject,
      { binary: true }
    );
  });
}
```

---

## 4. Database 스키마 변경

### 4.1 Project 모델 확장

```python
# project.py
class Project(Base):
    # 기존 필드들...

    # 자유 건축 모드 지원
    room_structure = Column(JSONEncodedDict, nullable=True)
    # {
    #   "mode": "free_build" | "template",
    #   "tiles": [...],  # FreeBuildTile[]
    #   "gridSize": 20,
    #   "tileSize": 0.5,
    #   "wallHeight": 2.5
    # }
```

### 4.2 Layout 모델 확장

```python
# layout.py
class Layout(Base):
    # 기존 필드들...

    # 타일별 텍스처/Depth 상태
    tile_state = Column(JSONEncodedDict, nullable=True)
    # {
    #   "textures": { "tile-id": "texture-url", ... },
    #   "depthMaps": { "tile-id": "depth-map-url", ... },
    #   "displacementScales": { "tile-id": 0.1, ... }
    # }
```

### 4.3 Migration 스크립트

```python
# alembic/versions/xxx_add_free_build_support.py
def upgrade():
    op.add_column('projects', sa.Column('room_structure', sa.TEXT(), nullable=True))
    op.add_column('layouts', sa.Column('tile_state', sa.TEXT(), nullable=True))

def downgrade():
    op.drop_column('layouts', 'tile_state')
    op.drop_column('projects', 'room_structure')
```

---

## 5. 작업 순서 및 예상 소요 시간

### Phase 1: 자유 건축 모드 (총 예상: 3-4일)

| 순서 | 작업 | 파일 | 예상 시간 |
|------|------|------|----------|
| 1 | 타입 정의 | `types/freeBuild.ts` | 1시간 |
| 2 | Zustand 스토어 | `store/freeBuildStore.ts` | 3시간 |
| 3 | 도구 툴바 UI | `BuildToolbar.tsx` | 2시간 |
| 4 | 자유 건축 3D 씬 | `FreeBuildScene.tsx` | 6시간 |
| 5 | 자동 벽 생성 | `freeBuildStore.ts` | 2시간 |
| 6 | 기존 RoomBuilder 통합 | `RoomBuilderComplete.tsx` 수정 | 3시간 |
| 7 | DB 마이그레이션 | `project.py`, migration | 2시간 |
| 8 | 백엔드 API 수정 | `room_builder.py` | 2시간 |
| 9 | 테스트 및 버그 수정 | - | 4시간 |

### Phase 2: AI Depth Map (총 예상: 2-3일)

| 순서 | 작업 | 파일 | 예상 시간 |
|------|------|------|----------|
| 1 | Depth API 구현 | `depth_estimation.py` | 4시간 |
| 2 | 프론트엔드 연동 | `DepthMapApplier.tsx` | 3시간 |
| 3 | DisplacementTileMesh | `DisplacementTileMesh.tsx` | 3시간 |
| 4 | Geometry Baking | `geometryBaker.ts` | 4시간 |
| 5 | GLB 내보내기 통합 | `RoomBuilderComplete.tsx` | 3시간 |
| 6 | 테스트 및 버그 수정 | - | 4시간 |

---

## 6. 의존성 추가

### Frontend (`package.json`)
```json
{
  "dependencies": {
    // 기존 의존성...
    // 추가 필요 없음 - Three.js에 이미 포함
  }
}
```

### Backend (`requirements.txt`)
```
# 기존 의존성...
transformers>=4.36.0
torch>=2.0.0
accelerate>=0.25.0
```

---

## 7. 리스크 및 대응

| 리스크 | 영향 | 대응 방안 |
|--------|------|----------|
| Depth 모델 GPU 메모리 | 서버 리소스 | CPU 폴백, 모델 양자화 |
| 브라우저 메모리 (많은 타일) | 프론트엔드 성능 | 타일 수 제한 (최대 1000개), LOD |
| Geometry Baking 속도 | 내보내기 지연 | Web Worker 사용, 진행률 표시 |
| UV 매핑 복잡성 | 텍스처 왜곡 | 바운딩 박스 기반 정밀 계산 |
