from fastapi import APIRouter, File, UploadFile, Depends, HTTPException, status
from sqlalchemy.orm import Session
from pathlib import Path
from typing import Dict, Optional
import logging
import base64
import json
import boto3
from botocore.exceptions import ClientError
from pydantic import BaseModel
import io
from PIL import Image
import numpy as np
import cv2

from app.database import get_db
from app.models import Project, User
from app.api.deps import get_current_user
from app.utils.glb_utils import extract_glb_dimensions

logger = logging.getLogger(__name__)

router = APIRouter()

# Initialize AWS Bedrock client (lazy initialization)
_bedrock_runtime = None

def get_bedrock_client():
    global _bedrock_runtime
    if _bedrock_runtime is None:
        try:
            _bedrock_runtime = boto3.client(
                service_name='bedrock-runtime',
                region_name='us-east-1'
            )
        except Exception as e:
            logger.warning(f"Failed to initialize Bedrock client: {e}")
    return _bedrock_runtime

# Pydantic model for AI generation request
class GenerateTextureRequest(BaseModel):
    prompt: str
    negative_prompt: Optional[str] = "blurry, low quality, distorted, watermark, text"
    seed: Optional[int] = None


@router.post("/upload-glb/{project_id}")
async def upload_room_glb(
    project_id: int,
    file: UploadFile = File(...),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
) -> Dict:
    """
    Upload GLB file generated by room builder.
    Auto-detects room dimensions from GLB.
    """
    logger.info(f"User {current_user.id} uploading room GLB for project {project_id}")

    # Verify project ownership
    project = db.query(Project).filter(Project.id == project_id).first()
    if not project:
        logger.error(f"Project {project_id} not found")
        raise HTTPException(status_code=404, detail="Project not found")

    if project.owner_id != current_user.id:
        logger.error(f"User {current_user.id} not authorized for project {project_id}")
        raise HTTPException(status_code=403, detail="Not authorized to modify this project")

    # Validate file type
    if not file.filename.lower().endswith('.glb'):
        raise HTTPException(
            status_code=400,
            detail="Invalid file type. Only GLB files are accepted."
        )

    try:
        # Read file content
        file_content = await file.read()
        file_size = len(file_content)

        # Create GLB directory if it doesn't exist
        glb_dir = Path("uploads/glb_files")
        glb_dir.mkdir(parents=True, exist_ok=True)

        # Generate unique filename
        filename = f"room_{project_id}_{current_user.id}.glb"
        file_path = glb_dir / filename

        # Save file
        with open(file_path, "wb") as f:
            f.write(file_content)

        logger.info(f"Saved GLB file to {file_path} ({file_size} bytes)")

        # Extract dimensions from GLB
        try:
            dimensions = extract_glb_dimensions(file_path)
            logger.info(f"Extracted dimensions from GLB: {dimensions}")
        except Exception as e:
            logger.warning(f"Failed to extract dimensions from GLB: {e}")
            # Use default dimensions if extraction fails
            dimensions = {
                'width': 5.0,
                'height': 3.0,
                'depth': 4.0
            }

        # Update project with GLB info
        project.has_3d_file = True
        project.file_type = 'glb'
        project.file_path = str(file_path)
        project.file_size = file_size
        project.room_width = dimensions['width']
        project.room_height = dimensions['height']
        project.room_depth = dimensions['depth']

        # Also update legacy fields for compatibility
        project.has_ply_file = False
        project.ply_file_path = None
        project.ply_file_size = None

        db.commit()
        db.refresh(project)

        logger.info(f"Successfully uploaded room GLB for project {project_id}")

        return {
            "message": "Room GLB uploaded successfully",
            "project_id": project_id,
            "dimensions": dimensions,
            "file_size": file_size,
            "file_path": str(file_path),
        }

    except Exception as e:
        logger.error(f"Error uploading room GLB: {e}")
        db.rollback()
        raise HTTPException(
            status_code=500,
            detail=f"Failed to upload room GLB: {str(e)}"
        )


def create_seamless_texture(image: np.ndarray, target_size: int = 256) -> np.ndarray:
    """
    Create a seamless texture using mirror tiling technique.
    """
    # Resize image to half of target size first
    half_size = target_size // 2
    resized = cv2.resize(image, (half_size, half_size), interpolation=cv2.INTER_LANCZOS4)

    # Create mirror tiles
    top_left = resized
    top_right = cv2.flip(resized, 1)
    bottom_left = cv2.flip(resized, 0)
    bottom_right = cv2.flip(resized, -1)

    # Concatenate tiles
    top_half = np.hstack([top_left, top_right])
    bottom_half = np.hstack([bottom_left, bottom_right])
    seamless = np.vstack([top_half, bottom_half])

    # Apply slight Gaussian blur at seams
    blended = seamless.copy()

    # Horizontal seam blur
    kernel_size = 5
    center_h = target_size // 2
    roi_h = blended[center_h - kernel_size:center_h + kernel_size, :]
    blurred_h = cv2.GaussianBlur(roi_h, (kernel_size, kernel_size), 0)
    blended[center_h - kernel_size:center_h + kernel_size, :] = blurred_h

    # Vertical seam blur
    center_v = target_size // 2
    roi_v = blended[:, center_v - kernel_size:center_v + kernel_size]
    blurred_v = cv2.GaussianBlur(roi_v, (kernel_size, kernel_size), 0)
    blended[:, center_v - kernel_size:center_v + kernel_size] = blurred_v

    return blended


def numpy_to_base64(image: np.ndarray) -> str:
    """Convert numpy array to base64 encoded JPEG string."""
    # Convert BGR to RGB
    image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

    # Convert to PIL Image
    pil_image = Image.fromarray(image_rgb)

    # Save to bytes buffer
    buffer = io.BytesIO()
    pil_image.save(buffer, format="JPEG", quality=90)

    # Encode to base64
    img_str = base64.b64encode(buffer.getvalue()).decode()

    return f"data:image/jpeg;base64,{img_str}"


@router.post("/generate-texture")
async def generate_texture(
    request: GenerateTextureRequest,
    current_user: User = Depends(get_current_user),
) -> Dict:
    """
    Generate a seamless tile texture using AWS Bedrock Stable Diffusion.
    """
    bedrock_runtime = get_bedrock_client()
    if not bedrock_runtime:
        raise HTTPException(
            status_code=503,
            detail="AI generation service is not available. Please check AWS configuration."
        )

    try:
        logger.info(f"Generating texture with prompt: {request.prompt}")

        # Enhance prompt for better tiling results
        enhanced_prompt = f"{request.prompt}, seamless texture, tileable pattern, high quality, detailed"

        request_body = {
            "taskType": "TEXT_IMAGE",
            "textToImageParams": {
                "text": enhanced_prompt,
                "negativeText": request.negative_prompt
            },
            "imageGenerationConfig": {
                "numberOfImages": 1,
                "quality": "premium",
                "height": 512,
                "width": 512,
                "cfgScale": 10.0,
            }
        }

        if request.seed is not None:
            request_body["imageGenerationConfig"]["seed"] = request.seed

        # Call AWS Bedrock Amazon Titan Image Generator
        logger.info("Calling Bedrock Amazon Titan Image Generator...")
        response = bedrock_runtime.invoke_model(
            modelId="amazon.titan-image-generator-v2:0",
            body=json.dumps(request_body),
            contentType="application/json",
            accept="application/json"
        )

        # Parse response
        response_body = json.loads(response['body'].read())
        logger.info("Bedrock response received")

        # Get base64 image from response
        if "images" not in response_body or len(response_body["images"]) == 0:
            raise HTTPException(status_code=500, detail="No image generated by Bedrock")

        base64_image = response_body["images"][0]

        # Decode base64 to image
        image_bytes = base64.b64decode(base64_image)
        nparr = np.frombuffer(image_bytes, np.uint8)
        image = cv2.imdecode(nparr, cv2.IMREAD_COLOR)

        if image is None:
            raise HTTPException(status_code=500, detail="Failed to decode generated image")

        logger.info(f"Image decoded: {image.shape}")

        # Create seamless texture
        seamless_texture = create_seamless_texture(image, target_size=256)
        logger.info(f"Seamless texture created: {seamless_texture.shape}")

        # Convert to base64
        texture_base64 = numpy_to_base64(seamless_texture)

        return {
            "texture_url": texture_base64,
            "size": 256,
            "prompt": request.prompt
        }

    except ClientError as e:
        error_code = e.response['Error']['Code']
        error_message = e.response['Error']['Message']
        logger.error(f"AWS Bedrock Error ({error_code}): {error_message}")

        # User-friendly error messages
        if error_code == "ValidationException":
            if "content filters" in error_message or "AUP" in error_message:
                user_message = (
                    "⚠️ Content filter blocked\n\n"
                    "The prompt violates AWS content policy.\n\n"
                    "Please avoid:\n"
                    "• Copyrighted character names\n"
                    "• Brand names\n"
                    "• Inappropriate content\n\n"
                    "Try prompts like:\n"
                    "• wooden floor\n"
                    "• marble texture\n"
                    "• concrete wall\n"
                    "• brick pattern"
                )
            else:
                user_message = f"Input error: {error_message}"
        elif error_code == "AccessDeniedException":
            user_message = (
                "⚠️ Model access denied\n\n"
                "AWS Bedrock Titan Image Generator is not enabled.\n"
                "Please contact administrator."
            )
        else:
            user_message = f"AWS Bedrock error ({error_code}): {error_message}"

        raise HTTPException(
            status_code=400 if error_code == "ValidationException" else 500,
            detail=user_message
        )
    except Exception as e:
        logger.error(f"Error generating texture: {e}")
        raise HTTPException(status_code=500, detail=f"Error generating texture: {str(e)}")


@router.get("/dimensions/{project_id}")
async def get_room_dimensions(
    project_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
) -> Dict:
    """
    Get room dimensions for a project.
    """
    project = db.query(Project).filter(Project.id == project_id).first()
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")

    if project.owner_id != current_user.id:
        raise HTTPException(status_code=403, detail="Not authorized to view this project")

    return {
        "project_id": project_id,
        "dimensions": {
            "width": project.room_width,
            "height": project.room_height,
            "depth": project.room_depth,
        },
        "has_3d_file": project.has_3d_file,
        "file_type": project.file_type,
    }